Offset      Field	    Size	    Purpose
0	        Magic       Bytes	    4 bytes	Identifies the protocol (e.g., 0x53 0x4E 0x54 0x4C for "SNTL")
4	        Version	    1 byte	    Rule #22: Allows for future protocol upgrades
5	        Flags	    1 byte	    Compression, Encryption, or Heartbeat markers
6	        Payload     Length	    4 bytes	Rule #20: Tells the receiver how many bytes to read next
10	        Payload	    N bytes	    The actual data (JSON, Protobuf, or Raw)
10+N	    CRC32	    4 bytes	R   ule #21: Ensures the data wasn't corrupted in transit


----Imagine you're sending secret messages between spies. You need a system that:
Identifies messages as yours (not enemy messages)
Protects messages from tampering
Structures messages so both sides understand them
Verifies messages arrived intact
That's exactly what this code does for computer networks!

┌─────────────────────────────────────────────────────────────┐
│                     THE SPY PACKAGE                         │
├──────────┬─────┬─────┬─────────────┬────────────┬───────────┤
│  MAGIC   │ VER │FLAGS│   LENGTH    │  PAYLOAD   │   CRC     │
│ "SNTL"   │  1  │ 0xAB│   12 bytes  │ "TOP SECRET│ 0xA1B2C3D4│
│ (4 bytes)│(1)  │ (1) │   (4 bytes) │  MESSAGE"  │ (4 bytes) │
└──────────┴─────┴─────┴─────────────┴────────────┴───────────┘

MAGIC "SNTL" = "This is a Sentinel message, not random noise!"
VERSION "1" = "Use decoding rulebook version 1"
FLAGS "0xAB" = "This message has special flags set"
LENGTH "12" = "Payload is 12 characters long"
PAYLOAD = "The actual secret message"
CRC = "Checksum to detect if message was tampered with

1) Check MAGIC
   ↓
2) Read LENGTH
   ↓
3) Wait until full frame arrives (HEADER + PAYLOAD + CRC)
   ↓
4) Use LENGTH to slice PAYLOAD
   ↓
5) Recompute CRC over (VERSION + FLAGS + PAYLOAD)
   ↓
6) Compare computed CRC with transmitted CRC
   ↓
7) If all pass → accept message


MAGIC   →  "Is this ours?"
VERSION →  "Which rulebook do I use?"
FLAGS   →  "How should I treat this message?"
LENGTH  →  "How big is the message?"
PAYLOAD →  "The actual content"
CRC     →  "Was anything altered?"

Byte Position:  0     4     5     6     10
              ┌─────┬─────┬─────┬────────────┐
              │ MAGIC │ VER │FLAGS│  LENGTH   │
              │ "SNTL"│  1  │ 0xAB│   000012  │
              └─────┴─────┴─────┴────────────┘

version: u8,      // Like: "Message format version 1"
flags: u8,        // Like: "Special flags: urgent, encrypted, etc."
payload: Bytes,   // Like: "The actual message content"

eg.
version: 1,                     // "Use rulebook v1"
flags: 0b10101011,              // "Flags: urgent=true, reply-needed=true, etc."
payload: Bytes::from("Hello!")  // "The actual message"

--- CRC Checksum (The Tamper Detector)
Did anyone change even a single letter on the pages?
CRC depends on LENGTH
CRC is only trusted after MAGIC passes
//(simplified)
Message: "HELLO" + Version: 1 + Flags: 0xAB
→ Math magic happens
→ Result: 0xDEADBEEF (a unique fingerprint)

If message changes even slightly:
"HELLO" → "HELLP" (just one letter!)
→ New CRC: 0xFEEDFACE (completely different!)

---payload_len_u32
let payload_len_u32 = u32::from_be_bytes([...]);
This line means:
Interpret these 4 bytes as one big-endian 32-bit integer.

Why big-endian?
Networks use network byte order = big-endian.

also wrote the length using:

dst.put_u32(payload_len as u32);
which writes in big-endian by default.

///Example

If the sender wrote:
LENGTH = 12

Then the 4 bytes on the wire are:
00 00 00 0C


code reconstructs:
u32::from_be_bytes([0x00, 0x00, 0x00, 0x0C]) == 12

---Extract the payload (ZERO-COPY!)
src.advance(HEADER_SIZE);                    // "Move past the header"
let payload = src.split_to(payload_len).freeze();  // "Take the payload WITHOUT copying"
src.advance(CRC_LEN);                        // "Move past the CRC"
