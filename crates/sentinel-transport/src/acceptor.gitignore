use std::sync::Arc;
use std::path::Path;
use std::time::Duration;
use tokio::net::TcpStream;
use tokio_rustls::TlsAcceptor;
use tokio_rustls::rustls::{ServerConfig, RootCertStore};
use tokio_rustls::rustls::server::WebPkiClientVerifier;

use crate::tls::TlsTransport;
use crate::tls_config::{load_certs, load_private_key};
use crate::error::{TransportError, TransportResult};

/// SentinelAcceptor is the entry point for all secure connections.
/// It maintains the Arc-shared TLS configuration to ensure zero-copy 
/// distribution of security policies across worker tasks.
pub struct SentinelAcceptor {
    inner: TlsAcceptor,
    handshake_timeout: Duration,
}

impl SentinelAcceptor {
    /// Constructor for standard TLS (Server-side encryption only)
    pub fn new(
        cert_path: &Path,
        key_path: &Path,
        handshake_timeout: Duration,
    ) -> anyhow::Result<Self> {
        Self::build_acceptor(cert_path, key_path, None, handshake_timeout)
    }

    /// Constructor for mTLS (Mutual TLS - Server & Client both present certs)
    /// Rule #19: mTLS optional support
    pub fn new_mtls(
        cert_path: &Path,
        key_path: &Path,
        ca_path: &Path,
        handshake_timeout: Duration,
    ) -> anyhow::Result<Self> {
        Self::build_acceptor(cert_path, key_path, Some(ca_path), handshake_timeout)
    }

    /// Internal builder to enforce DRY (Don't Repeat Yourself) and 
    /// Rule #16 (TLS 1.3 only)
    fn build_acceptor(
        cert_path: &Path,
        key_path: &Path,
        ca_path: Option<&Path>,
        handshake_timeout: Duration,
    ) -> anyhow::Result<Self> {
        let certs = load_certs(cert_path)?;
        let key = load_private_key(key_path)?;

        // Initialize the builder with Safe Defaults
        let builder = ServerConfig::builder()
            .with_safe_default_cipher_suites() // Rule #17: Pinning handled by rustls defaults
            .with_safe_default_kx_groups()
            .with_safe_default_protocol_versions()?; // This allows TLS 1.3 + 1.2 by default

        // Rule #16 & #18: Hard-limit to TLS 1.3 and strict validation
        let mut config = if let Some(ca) = ca_path {
            let client_auth_certs = load_certs(ca)?;
            let mut root_store = RootCertStore::empty();
            for cert in client_auth_certs {
                // Rule #18: Ensure we only trust our specific CA
                root_store.add(cert.0[0].clone().into())?;
            }
            
            let verifier = WebPkiClientVerifier::builder(Arc::new(root_store)).build()?;
            builder.with_client_cert_verifier(verifier)
        } else {
            builder.with_no_client_auth()
        }
        .with_single_cert(certs, key)?;

        // Rule #23 & #28: ALPN is vital for custom protocols to reject non-Sentinel traffic
        config.alpn_protocols = vec![b"sentinel-v1".to_vec()];

        Ok(Self {
            inner: TlsAcceptor::from(Arc::new(config)),
            handshake_timeout,
        })
    }

    /// Accept a raw TCP stream and upgrade it to TLS.
    /// Rule #8: Timeouts on all I/O
    /// Rule #28: Rate-limiting the handshake via timeout
    pub async fn accept(&self, stream: TcpStream) -> TransportResult<TlsTransport> {
        // We wrap the handshake in a timeout to prevent malicious clients 
        // from holding resources open indefinitely (Slowloris protection).
        let handshake_future = self.inner.accept(stream);
        
        match tokio::time::timeout(self.handshake_timeout, handshake_future).await {
            Ok(result) => {
                let tls_stream = result.map_err(TransportError::Tls)?;
                Ok(TlsTransport::new(tls_stream))
            }
            Err(_) => Err(TransportError::HandshakeTimeout),
        }
    }
}


cert.pem ──┐
           ├─→ SentinelAcceptor::new() → TLS Handshake → Secure Connection
key.pem  ──┘
     │           │
     │           │
     ▼           ▼
 load_certs()   load_private_key()
     │           │
     ▼           ▼
  certs[]      key
     │           │
     ▼           ▼
  ServerConfig::builder()
            │
            ▼
  ServerConfig (with certs + key)
            │
            ▼
      Arc::new()        [Share across connections]
            │
            ▼
   TlsAcceptor::from()
            │
            ▼
  SentinelAcceptor.acceptor